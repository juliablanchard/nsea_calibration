---
title: 'From Steady State To Changes Through Time'
author: "Julia Blanchard"
date: "22/08/2022"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Confronting mizer models with time series data

In a previous blog post by Gustav Delius, 3 stages of building mizer
models are described:

1.  Collect information about the important species in your ecosystem
    and how they are fished. This includes physiological parameters for
    the species as they might be found on FishBase, but also information
    about how abundant the species are and how they are being fished.

2.  Create a mizer model that in its steady state reproduces the
    time-averaged observed state of your fish community.

3.  Tune the model parameters further to also reproduce time-series
    observations that capture some of the system's sensitivity to
    perturbations, like changes in fishing pressure.

This blog post will focus on the transition between stage 2 and 3.

# Example we will use

For this example, I will use the North Sea model, but this time
calibrated using catch data only.

Some of the functions we will be using are still in active development
in the [mizerExperimental](https://sizespectrum.org/mizerExperimental/)
and mizerHowTo packages. Therefore we will always want to make sure we
are loading the latest version of the package with

```{r,echo=FALSE}
remotes::install_github("sizespectrum/mizerExperimental", ref = "tuneMR")
remotes::install_github("sizespectrum/mizerMR")
library(mizerExperimental)
library(mizerMR)
library(tidyverse)


#library(mizerHowTo)

library(parallel)
library(pbapply)
library(lhs)
library(tgp)
source("calibration_functions.R") # mve to howTO

```

The North Sea model parameters which includes time-averaged biomass and
yield observations needed to carry out this example. Except for sandeel, all of the biomasses (grams) are from survey data, corrected for catchability, and averaged over 1985-1995 for the whole area of the North Sea. For sandeel stock assessment spawner biomass was used. For catches discards are included, with the exception of Gurnard and Dab which, along with catchability values, are the same as in Blanchard et al. 2014.

```{r, code_folding=TRUE, layout="l-body-outset"}
species_params <- readRDS("data-for-steady-to-time/ns_calib_param.RDS")

```

# A recap on getting the steady state

There are many different ways to calibrate or tune models using
time-averaged data. I usually do this in mizer with the *project*
function, outputting the time-averaged biomass or catches and
calculating the differences with observations using a least-squares
approach (usually optimisation, not always). This usually comes with
challenges,which I won't go into here, but it can get messy.

So I was excited to check out the new developments, which I think could
saves the optimisation step for stage 3: fitting to times series data.

The first step of stage 2: steady state is very handy. Instead of
setting up the model and projecting through time, we will use `steady()`
to get the steady state with constant reproduction (and the adjusted the
reproduction parameters, the reproductive efficiencies or erepro). It
then sets the resulting steady state as the initial state of the
MizerParams object.

We can do this by setting up the mizer params object by combining
species parameters, interaction matrix, and the gear parameters for the
model.

```{r,code_folding=TRUE,echo = F,message=F, warning=F}
gear_params<-data.frame(species = species_params$species,
               gear = species_params$species,
               sel_func = "sigmoid_length",
               l25 =  c(7.6, 9.8, 8.7, 10.1, 11.5, 19.8, 16.4, 19.8, 11.5,
                        19.1, 13.2, 35.3),
               l50 = c(8.1, 11.8, 12.2, 20.8, 17.0, 29.0, 25.8, 29.0, 17.0,
                       24.3, 22.9, 43.6),
               catchability = species_params$catchability)

params <- newMultispeciesParams(species_params = species_params,gear_params=gear_params,inter,initial_effort = 1,max_w=1e6) # inter comes with loading "mizer")
species_params(params)$gear<-species_params(params)$species
species_params(params)$biomass_cutoff <- 10
species_params(params)["Sandeel",]$biomass_cutoff <- 4
params <- steady(params)
plotlySpectra(params, power = 2)
```

We can project the new params object to steady state and then check it.

```{r,code_folding=TRUE}
sim <- project(params,effort=1, t_max = 100)
plot(sim)
gear_params(params)
```

This shows there is a steady state with coexistence for all species,
reasonable feeding level and size spectrum. How well do the biomasses match the time-averaged observations (here obtained from stock assessments)?

Using the handy function 'calibrateBiomass' scales the system (background
resource and other linked parameters) to get the total biomass in the
model to match up with the total observed biomass of all 12 species.
Then 'matchBiomass' calculates the scaling needed for each of the species'
yields to match up to their observed ones. This part is a bit of an
iterative process: match yield, calculate steady steady, re-check match
to yield and repeat until satisfactory.

I repeated the below 7 times, which gives a total relative error of
0.018.

```{r}
params <- params %>% calibrateBiomass() %>%  matchBiomasses() %>%  steady()
plotBiomassObservedVsModel(params,ratio=T)
```

Now let's check the time-averaged yields.

```{r}
plotYieldObservedVsModel(params,ratio=F)
```
The model is massively overestimating the yields, likely to do with how the catchability coefficients have been parameterised from stock assessment estimates of fishing mortality rates that capture all age ranges. Also, we have not yet set the sensitivity to fishing or density dependence in the model. Let's do that first and then come back to the observed yields.

Let's also check we are at steady state and have a look to
see if the size spectra look OK:

```{r,code_folding=TRUE}
sim <- project(params,effort=initial_effort(params),t_max = 10)
plotCalibration(sim,stage=1)

```

The diagnostic plots look reasonable and to compete this step we would
need to fully check all of these plots. The mizer course notes
[[here](https://course.mizer.sizespectrum.org/build/)] go through many
helpful steps needed to tune, evaluate and check this stage. We will
accept these parameters and move to the next step.

# Setting up sensitivity to fishing

The next key step prior to modelling change through time involves
checking and tuning each species' sensitivity to fishing, which is
determined by the reproduction parameters (also see here:
<https://blog.mizer.sizespectrum.org/posts/2021-08-03-density-dependence-in-reproduction/>).

The sensitivity to fishing is set by the *reproduction_level* and this
parameter and tuning process has a big effect on how species collapse
and/or recover through time. We can check these parameters using the
code below:

```{r,code_folding=TRUE}
reproduction_level <- getReproductionLevel(params)
reproduction_level
```

And we can double check to see what the Rmax and erepro values, for each
species.

```{r,code_folding=TRUE,warning=FALSE}
species_params(params)[,c("erepro", "R_max")]
```

There seems to very high sensitivity to fishing (low erepro) and low
levels density dependence (little or no cap on the reproductive output
at high levels of adult biomass, indicated by very high R_max values or
*Inf*) for some species. Both of these parameters combined affect
reproduction_level, which is low for all species.

In a previous blog Gustav showed how we can tune the sensitivity to
fishing using the reproduction_level alone. The advantage is that tuning
this parameter does not affect the steady state, whereas tuning R_max
and/or erepro, through optimisation, may not guarantee a steady state is
reached.

Tuning sensitivity to fishing involves adjusting the reproduction_level
examining yield curves at equilibrium (see more
[here](https://course.mizer.sizespectrum.org/use/tune-resilience.html)).
Choices have to be made for each species, usually based on
single-species theory or could be set based on prior ecological
knowledge about the resilience of the species to fishing.

Yield curves would look dome-shaped to be consistent with theory with
values of Fmsy consistent with the Fmsy that would reach MSY for each
species.

We can check the yield curves for every species, and tune the
reproduction parameters to ensure the Fmsy estimates are in line with
theory or other perhaps information we may have from stock assessments.
For data limited stocks there are ways to estimate this form other
parameters and information on FishBase, see this
[paper](https://onlinelibrary.wiley.com/doi/full/10.1111/faf.12190) for
example. We can use the resilience from FishBase as a guide, assuming
that an upper limit for Fmsy (resilience in brackets) would be 0.25
(low), 0.4 (medium) and 0.75 (high). For all of the species in the north
sea model are classified as "Medium" in terms of resilience on FishBase.
An alternative approach to capture differences could be to work out the
level of total mortality rates (without fishing) (perhaps at size at
maturation) and assume that as approximation for Fmsy for each species,
but let's start with this simpler approach where we set the
reproduction_level to 0.5 for all species and adjust values after
checking the yield curves for each species.

```{r,echo=FALSE}
params<-setBevertonHolt(params,reproduction_level = 0.5)
params<-steady(params,return_sim = F)


specieslist<-species_params$species
for (i in 1:length(specieslist)) {
  
temp_plot<- plotYieldCurve(params,species=specieslist[i],F_max=1.2)

ggsave(temp_plot, file=paste0("yieldcurve_", i,".png"), width = 14, height = 10, units = "cm")

}

```


Norway pout, whiting and haddock appear insensitive to fishing and needed adjustments.

```{r,echo=FALSE}
params<-setBevertonHolt(params,reproduction_level = c("N.pout"=0.001,"Whiting"=0.01,"Haddock"=0.2))
params<-steady(params,return_sim = F)

plotYieldCurve(params,species="N.pout",F_max=1.2)
plotYieldCurve(params,species="Whiting",F_max=1.2)
plotYieldCurve(params,species="Haddock",F_max=1.2)


```



But how do we know what the reproduction_level and sensitivity to
fishing should be in real ecosystems, when so may processes affect this
in reality?

An additional approach could be to
further confront the model with time series data of catches, to help
refine estimates of the reproduction parameters (e.g. step 3 above).

# Forcing the model through time

We could used the tuned parameters and simply force the model through
time with changes in fishing mortality. That would allow us to examine
whether modeled catches decline in a way that is consistent with
observed catches and/or our expectations from the yield curves.

To do this we need to incorporate time-varying fishing into the model. 

For the North Sea we can use ICES catch data and fishing mortality rates
from stock assessments to examine this problem. We have can use fishing
mortality rates directly in mizer by setting catchability to 1. Since
the time series goes back further than the years for which the
time-averaged model was calibrated, we will set the initial value to the
levels in the first year of the data, and re-estimate the steady state
to use as initial values for our simulations.

```{r,code_folding=TRUE}
# read in stored fishing mortality (here called effort) time series, here expressed relative to  time-averaged values for the calibration period 1985-1995
effort <- readRDS("data-for-steady-to-time/effortTime.RDS")
meanE<-colMeans(effort[as.character(1985:1995),])
effort<-sweep(effort, 2, meanE,"/")[as.character(1985:2019),]
# instead of an initial effort of 1 lets start the model off with the level of fishing using the first year of the input values

#params<- projectToSteady(params, effort = effort[1,],t_max = 200)

simt<- project(params, effort = effort)
plotlyYield(simt)
plotlyBiomass(simt)
```

We can then read in and add the North Sea catch data to our plot.

```{r,warning=FALSE}
yields_obs <-readRDS("yields_time.RDS")
names(yields_obs)<-c("Year","Species","Yield")
yields_obs$Yield<-yields_obs$Yield*1e6 # convert to grams per yr
yields_obs<-yields_obs[yields_obs$Year>=1985,]
plotYield(simt) +    facet_wrap(~Species,scales="free_y")+
geom_point(data=yields_obs,aes(x = Year, y = (Yield), colour = Species),size=0.5)
```

Currently, for some species we can see the modeled yields are not near
the data time series, but others look sort of ok. The stocks seem to
collapse earlier in the model than the data. Remember we we did not calibrate the model to produce the catches  at steady state yet.

So before we proceed with using the time series to estimate parameters, let's  first see if we can get the model to produce yields that in the same ballpark as the time-averaged yields.

```{r}
plotYieldObservedVsModel(params)
```

Here we can see that the model overestimates yields by a lot.


Let's estimate the catchability based on these time averaged yields. We can do this by writing an "error function" that allows us to optimise (find the minimum value of the error) by adjusting the values of a parameter, in this case catchability. Later on, we will apply time series expressing changes in F (from stock assessments) relative to the initial catchability values.

```{r}
getErrorYield<-function (vary, params, data_type = "catch", tol = 0.1,timetorun = 10,species=NULL) 
{
    if (!is.null(species)) {
  whichspecies<-which(gear_params(params)$species==species)}
   
  if (is.null(species)) {
     whichspecies<-1:length(gear_params(params)$species)}
  
    gear_params(params)$catchability[whichspecies] <-vary     
    params <-   projectToSteady(params, distance_func = distanceSSLogN, tol = tol, t_max = 200, return_sim = F)
    sim <- project(params, effort = 1, t_max = timetorun, progress_bar = F)
    model <- getYield(sim)[timetorun, whichspecies ]
    observed <- species_params(params)$yield_observed[whichspecies]
    ratio <- model/observed
    # total relative error  to be consistet with plots
    error <- round(sum(abs(1 - ratio)), digits = 3)
    # or could calculate sum of squared errors on log scale 
    # log_ratio <- log(ratio)
    # error <- (sum(log_ratio^2))
    return(error)
}
vary=gear_params(params)$catchability
getErrorYield(vary,params,species=NULL)
```



Now we will use optimisation to help estimate the catchabilities for each species, that minimises the above overall error. Why I Use L-BFGS-B. lower and upper value

```{r}
sample_params<-function(vary){
# set up workers
  noCores <- parallel::detectCores() - 1 # keep some spare core
  cl <- parallel::makeCluster(noCores, setup_timeout = 0.5)
  setDefaultCluster(cl = cl)
  clusterExport(cl, varlist = "cl",envir=environment())
  clusterEvalQ(cl, {
    library(mizerExperimental)
    library(optimParallel)
  })

num_species<-12
# num runs
num_iter=1000
# set the upper and lower bounds for each variable

rect_vary<-cbind(vary*0.6,vary*0.9)

set.seed(123)
parameters_new <- data.frame(lhs(num_iter, rect_vary))
names(parameters_new)<-row.names(species_params(params))

parameters_new$error<-pbapply(parameters_new,1,getErrorYield,params,cl=cl)

return(parameters_new)

stopCluster(cl)
}
#save error
#parameters_new<-sample_params(vary=vary)
saveRDS(parameters_new,"lhs_paramspace.RDS")

```

  
plot error
```{r}
error<-melt(parameters_new,id.vars ="error")
ggplot(data=error,aes(x=value,y=error)) + geom_point() + facet_grid(.~variable)
```
  
  
 

Find param set with the lowest error.

```{r,code_folding=TRUE,eval=F}
findmin<-which(parameters_new$error==min(parameters_new$error,na.rm=T))

result<-parameters_new[findmin,]
#repeat above
parameters_new<-sample_params(vary=unlist(result[1:12]))
```

then check plot and quickly? optimize species at a time?

```{r}
gear_params(params)$catchability<-unlist(result[1:12]) 
params<-steady(params)
plotYieldObservedVsModel(params)
```
```{r}
species_result<-data.frame(species=species_params$species, catchability=rep(0,12),species_error=rep(0,12))

optbyspecies<-function(speciesi){
out<-optimize(getErrorYield,interval=c(0,1), params,species=speciesi)
return(cbind(out$minimum,out$objective))
}

#species_result[,c(2:3)]<-pbapply(species_result,1,optbyspecies)

for (i in 1:12) {
out<-optbyspecies(species_result[i,1])
species_result[i,c(2:3)]<-out
}
```

Plug it back in to model

```{r}
gear_params(params)$catchability<-species_result[,2]
params<-steady(params)
plotYieldObservedVsModel(params)
```

need to turn above into a function and enable the ranges to change - based on relative differences to most recent values run.
or just run the fastOptim - which runs the model.

# check biomass again


Recalibrate with match biomasses again? 
```{r}
params2 <- params2 %>% calibrateBiomass() %>%  matchBiomasses() %>%  steady()
plotBiomassObservedVsModel(params2,ratio=T)
plotYieldObservedVsModel(params2,ratio=F)

```




# Using the time series data to estimate reproduction parameters

What would the reproduction parameters need to be in order to fit the
overall time series data better?

One issue could be that the *erepro* values we derived for the steady
state make the species much more reactive to fishing. Let's examine how
sensitive the time series (and their visual agreement to data) look when
we change our assumptions about *reproduction_level* directly for a
species.

```{r}
# params2 <- setBevertonHolt(params, reproduction_level = c("Cod" = 0.9))
 params2<- projectToSteady(params2, effort = effort[1,])
 simt2<- project(params2 , effort = effort)

 plotYield(simt2) +    facet_wrap(~Species,scales="free_y")+
 geom_point(data=filter(yields_obs),aes(x = Year, y = (Yield), colour = Species),size=0.1)

```

Here we can see that reducing the reproduction level does have a big
effect on when the stocks start collapsing, as expected. And having the
values low doesn't seem consistent with the data.

Given we have much more data now than in the time-averaged calibration
we can estimate more parameters. While more advanced statistical
approaches exist to do this (here and here) we will start simpler. 1) We
start with a function the describe how the model catches will be
compared with the observations - an error or objective function.The
function *getErrorTime* is the function we can used to estimate the
error with catches through time.

2)  We select and set up a range of parameters to estimate. Getting a
    suitable range of parameter values can be tricky. Optimisation
    schemes do this automatically with the next step in a search for
    parameters but can be time-consuming.

3)  We run the model with lots and lots of different parameter
    combinations and determine the lowest error across all of these
    (from the errorFunction) to see how what the model estimates as the
    best (most likely) parameter set, given the data. Optimisation
    approaches are seeking to find the overall minimum value that is
    achievable.

Below we set up a "latin hypercube" sampling scheme to ensure a good
spread of parameters. We can run all these combinations through the
model very quickly using a package called *pbapply*.

Because running so many iterations of the model is computationally
intensive so we can run the below using multiple computer cores and
using *parallel*.



```{r,code_folding=TRUE,eval=F}
# set up workers
  noCores <- parallel::detectCores() - 1 # keep some spare core
  cl <- parallel::makeCluster(noCores, setup_timeout = 0.5)
  setDefaultCluster(cl = cl)
  clusterExport(cl, varlist = "cl",envir=environment())
  clusterEvalQ(cl, {
    library(mizerExperimental)
    library(optimParallel)
  })
  
num_species<-12
# num runs
num_iter=1000
# set the upper and lower bounds for each variable
rect_vary<-cbind(rep(0.5,num_species),rep(0.9999,num_species))
set.seed(123)
parameters_new <- data.frame(lhs(num_iter, rect_vary))
names(parameters_new)<-row.names(species_params(params))

parameters_new$error<-pbapply(parameters_new,1,getErrorTime,params2,dat=yields_obs,effort,cl=cl)

stopCluster(cl)
#save error
saveRDS(parameters_new,"lhs_paramspace.RDS")
```

Find param set with the lowest error.

```{r,code_folding=TRUE,eval=F}
findmin<-which(parameters_new$error==min(parameters_new$error,na.rm=T))

result<-parameters_new[findmin,]
```

Plug it back into the model and compare the error values.

```{r,code_folding=TRUE,eval=F}
params_lhs<-params2
params_lhs<-setBevertonHolt(params_lhs, reproduction_level = result[1:12])

# check error and compare with original error
(new<-getErrorTime(vary=result[1:12],params=params_lhs,effort,yields_obs,variable = "reproduction_level"))

(original<-getErrorTime(getReproductionLevel(params2), params2,effort, yields_obs,variable = "reproduction_level"))

```

# Optimisation

We could then pass the error function to *fastOptim()*, which uses
*optimParallel* to estimate the lowest sum of squared errors between the
observed and modelled catches for all species' time series. If you want
to see how to write the error function type "getErrorTime" to see what
it contains.

You may want to skip the below step as it could take a while to run.

- Add catchability to estimation....
- remove/show fastOptim?

```{r,code_folding=TRUE,eval=F}
# set up workers
  noCores <- parallel::detectCores() - 1 # keep some spare core
  cl <- parallel::makeCluster(noCores, setup_timeout = 0.5)
  setDefaultCluster(cl = cl)
  clusterExport(cl, varlist = "cl",envir=environment())
  clusterEvalQ(cl, {
    library(mizerExperimental)
    library(optimParallel)
  })

vary<-c(as.numeric(getReproductionLevel(params2)),gear_params(params)$catchability)

optim_result <- optimParallel::optimParallel(par=vary,getErrorTime,params=params_optim, effort =effort,dat = yields_obs, method   ="L-BFGS-B", lower=c(rep(0.01,(dim(params_optim@species_params)[1])*2)), upper= c(rep(0.9,(dim(params_optim@species_params)[1])*2)),                                parallel=list(loginfo=TRUE, forward=TRUE))

stopCluster(cl)
  
# compare the error to the error obtained in the above chunk
#(optim_error<-getErrorTime(getReproductionLevel(sim_optim@params), sim_optim@params,effort, yields_obs,variable = "reproduction_level"))

```

Next, we can check how much better the error is and how this affects our
interpretation when we plot the data.

```{r,code_folding=TRUE,eval=F}
# assign these to the param object
#params_optim<-params_lhs
params_optim<-setBevertonHolt(params2,reproduction_level=optim_result$par[1:12])
gear_params(params_optim)$catchability<-optim_result$par[13:24]
params_optim<- projectToSteady(params_optim, effort = effort[1,])
simt_optim<- project(params_optim, effort = effort)

plotYield(simt_optim) +    facet_wrap(~Species,scales = "free")+
geom_point(data=filter(yields_obs),aes(x = Year, y = (Yield), colour = Species),size=0.1)

getReproductionLevel(params_optim)


plotYieldObservedVsModel(params_optim)
```

The error hasn't really reduced that much through the parameter space
sampling or optimisation of reproduction_level and the plots do not seem
remarkably different, though improved.

[SHOW HOW THIS COMPARES TO WIDELY USED R_max OPTIMISATION, with/out
erepros set to values in jacobsen?]







# Summary

-   After arriving at a steady state that fit the time-averaged catch
    data pretty well (using matchYields), we needed to set the
    sensitivity to fishing via the level of density dependence in our
    model. Initially we arbitrarily chose a high level- 0.9, but this is
    an important parameter in terms of understanding how stocks collapse
    and recover to fishing and is likely also to be species-specific.

-   We confronted the model with time-series of fishing mortalities and
    catch data. From this we saw that lower values of
    *reproduction_level* resulted in stock collapse earlier in the time
    series.

-   We explored a couple of different approaches to simultaneously
    estimate the reproduction_level for all species in the model. The
    best parameter set given the data revealed very high levels of
    density dependence for all species (except N.pout, Herring, and
    Gurnard).

-   Neither of the estimation methods revealed a pattern in the level of
    density dependence with weight at infinity. It would be interesting
    to know whether or not the modeled catches fit the data better using
    our previous *Rmax* estimation approach.

-   While we did not explore it, the modeled catches are very sensitive
    to the initial fishing mortality rates. My next exploration aims to
    investigate whether we draw similar conclusions when we do not use
    inputs from single-species stock assessments.

#### Acknowledgements

Thank you Gustav Delius and Asta Audzijonyte for the push to write
this blog and the stimulating discussions on this topic. Thank you Romain Forestier for help coding and implementing functions into the mizerHowTo package.
